---
title: 内存5大区
date: 2015-1-5 21:12:18
tags:
    - iOS开发
    - OC
---

# iOS程序中的内存分配分为5大区
- 内存5大区:堆,栈,方法区,全局区,常量区
- 栈:不需要手动管理内存,会自动清理栈中的内存
- 堆: 需要手动管理内存
- 静态区:又称全局区 

### 基本概念
- 在计算机中,运行的应用程序的数据都是保存在内存中的,不同类型的数据保存的内存区域不同

<!--more-->

## 内存分区
---
### 1.栈区
---
- 栈区由编译器自动分配并释放，存放函数的参数值，局部变量等。栈是系统数据结构，对应线程/进程是唯一的。
 - 优点是快速高效
 - 缺点是有限制，数据不灵活。［先进后出］

- 栈空间分静态分配 和动态分配两种。
 - 静态分配是编译器完成的，比如自动变量(auto)的分配。
 - 动态分配由alloca函数完成。
 - 栈的动态分配无需释放(是自动的)，也就没有释放函数。
 - 为可移植的程序起见，栈的动态分配操作是不使用的一般
 
#### 系统响应
- 栈：存储每一个函数在执行的时候都会向操作系统索要资源，栈区就是函数运行时的内存，栈区中的变量由编译器负责分配和释放，内存随着函数的运行分配，随着函数的结束而释放，由系统自动完成。
*注意：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。*

#### 申请大小的限制
- 栈是向低地址扩展的数据结构，是一块连续的内存的区域。是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是一个编译时就确定的常数 ,如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。
- *内存由系统自动分配,速度快,不会产生内存碎片*


 
### 2.堆区
---
- 堆区由程序员分配和释放，如果程序员不释放，程序结束时，可能会由操作系统回收 ，比如在ios 中 alloc 都是存放在堆中。
 - 优点是灵活方便，数据适应面广泛
 - 缺点是效率有一定降低。［顺序随意］
- 堆是函数库内部数据结构，不一定唯一。
	- 不同堆分配的内存无法互相操作。
	- 堆空间的分配总是动态的
*虽然程序结束时所有的数据空间都会被释放回系统，但是精确的申请内存，释放内存匹配是良好程序的基本要素。*

#### 系统响应
- 操作系统有一个记录空闲内存地址的链表。
- 当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。
- 由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中

#### 申请大小的限制
- 堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
- 有alloc分配的内存,速度较慢,会产生内存碎片,但是使用方便

### 3.全局区(静态区) 
---
- 全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量存放在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后由系统释放。 

### 4.常量区
---
- 常量区,存放常量字符串,程序结束后由系统释放

### 5.程序代码区(方法区)
---
- 存放函数的二进制代码
]


# 5大区在内存中分布

![内存分布图](http://upload-images.jianshu.io/upload_images/1494773-fc9423bca3512c6e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

---






